#include <gtest/gtest.h>
#include "detector.h"
#include <opencv2/opencv.hpp>
#include <filesystem>
#include <chrono>
#include <cstdlib>

namespace fs = std::filesystem;

#ifndef DATASET_DIR
#define DATASET_DIR "."
#endif

#ifndef CASCADE_PATH
#define CASCADE_PATH "teacher_dataset/haarcascade_frontalface_default.xml"
#endif

#ifndef RESULTS_DIR
#define RESULTS_DIR "results"
#endif

#ifndef BUILD_BIN_DIR
#define BUILD_BIN_DIR "."
#endif

static const std::string kCascade = CASCADE_PATH;
static const std::string kFaceImg = std::string(DATASET_DIR) + "/ferrer.jpeg";

// 1. Check that the cascade loads correctly
TEST(Detector, InitCascadeOk) {
    EXPECT_NO_THROW(init_cascade(kCascade));
}

// 2. Check that an exception is thrown for an invalid path
TEST(Detector, InitCascadeBadPath) {
    EXPECT_THROW(init_cascade(std::string(CASCADE_PATH) + ".missing.xml"), std::runtime_error);
}

// 3. Check that there are no detections on an empty image
TEST(Detector, EmptyImageNoDetections) {
    init_cascade(kCascade);
    cv::Mat img = cv::Mat::zeros(480, 640, CV_8UC3);
    auto dets = detect_faces(img);
    EXPECT_TRUE(dets.empty());
}

// 4. Check real face detection on an existing image
TEST(Detector, FaceImageHasDetections) {
    init_cascade(kCascade);
    cv::Mat img = cv::imread(kFaceImg);
    ASSERT_FALSE(img.empty()) << "Test image not found: " << kFaceImg;
    auto dets = detect_faces(img);
    EXPECT_GE(dets.size(), 1) << "No faces detected on: " << kFaceImg;
    for (auto& d : dets) {
        EXPECT_GE(d.x, 0);
        EXPECT_GE(d.y, 0);
        EXPECT_LE(d.br().x, img.cols);
        EXPECT_LE(d.br().y, img.rows);
    }
}

// 5. Check that drawing faces keeps the same size
TEST(Detector, DrawFacesKeepsSize) {
    init_cascade(kCascade);
    cv::Mat img = cv::imread(kFaceImg);
    ASSERT_FALSE(img.empty());
    auto dets = detect_faces(img);
    cv::Mat vis = draw_faces(img, dets);
    EXPECT_EQ(vis.size(), img.size());
}

// 6. Check that repeated cascade initialization works without errors
TEST(Detector, CascadeReinit) {
    EXPECT_NO_THROW({
        init_cascade(kCascade);
        init_cascade(kCascade);
    });
}

// 7. Check that detection runs fast enough (< 0.5s)
TEST(Detector, PerformanceCheck) {
    init_cascade(kCascade);
    cv::Mat img = cv::imread(kFaceImg);
    ASSERT_FALSE(img.empty());
    auto start = std::chrono::high_resolution_clock::now();
    auto dets = detect_faces(img);
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed = end - start;
    EXPECT_LT(elapsed.count(), 0.5) << "Face detection is too slow: " << elapsed.count() << "s";
}

// 8. Integration test: CLI creates output files in results/
TEST(Integration, FaceDetectCreatesOutputFiles) {
    fs::path results_dir = RESULTS_DIR;
    if (fs::exists(results_dir)) {
        for (auto& entry : fs::directory_iterator(results_dir)) fs::remove(entry.path());
    } else {
        fs::create_directories(results_dir);
    }

    const std::string cli = std::string(BUILD_BIN_DIR) + "/face_detector";
    int ret = std::system(cli.c_str());
    EXPECT_EQ(ret, 0) << "face_detector failed to execute";

    size_t count = 0;
    for (auto& entry : fs::directory_iterator(results_dir)) {
        if (entry.path().extension() == ".jpg") count++;
    }
    EXPECT_GT(count, 0) << "No result images were generated by face_detector";
}
